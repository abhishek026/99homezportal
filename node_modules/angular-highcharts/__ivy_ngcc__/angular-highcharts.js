import * as Highcharts from 'highcharts';
import { chart, stockChart, mapChart } from 'highcharts';
import * as ɵngcc0 from '@angular/core';
export { Highcharts };
import { Directive, ElementRef, Input, Inject, Injectable, InjectionToken, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class Chart {
    /**
     * @param {?} value
     * @return {?}
     */
    set options(value) {
        this._options = value;
        if (this.ref) {
            this.ref.update(value);
        }
    }
    /**
     * @return {?}
     */
    get options() {
        if (this.ref) {
            return this.ref.options;
        }
        return this._options;
    }
    /**
     * @param {?=} options
     */
    constructor(options = { series: [] }) {
        // init series array if not set
        if (!options.series) {
            options.series = [];
        }
        this.options = options;
    }
    /**
     * Add Point
     * \@memberof Chart
     * @param {?} point         Highcharts.DataPoint, number touple or number
     * @param {?=} serieIndex    Index position of series. This defaults to 0.
     * @param {?=} redraw        Flag whether or not to redraw point. This defaults to true.
     * @param {?=} shift         Shift point to the start of series. This defaults to false.
     * @return {?}
     */
    addPoint(point, serieIndex = 0, redraw = true, shift = false) {
        if (this.ref && this.ref.series.length > serieIndex) {
            this.ref.series[serieIndex].addPoint(point, redraw, shift);
            return;
        }
        // keep options in snyc if chart is not initialized
        if (this.options.series.length > serieIndex) {
            this.options.series[serieIndex].data.push(point);
        }
    }
    /**
     * Add Series
     * \@memberof Chart
     * @param {?} serie         Series Configuration
     * @param {?=} redraw        Flag whether or not to redraw series. This defaults to true.
     * @param {?=} animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
     * @return {?}
     */
    addSerie(serie, redraw = true, animation = false) {
        if (this.ref) {
            this.ref.addSeries(serie, redraw, animation);
            return;
        }
        // keep options in snyc if chart is not initialized
        this.options.series.push(serie);
    }
    /**
     * Remove Point
     * \@memberof Chart
     * @param {?} pointIndex    Index of Point
     * @param {?=} serieIndex    Specified Index of Series. Defaults to 0.
     * @return {?}
     */
    removePoint(pointIndex, serieIndex = 0) {
        if (this.ref &&
            this.ref.series.length > serieIndex &&
            this.ref.series[serieIndex].data.length > pointIndex) {
            this.ref.series[serieIndex].removePoint(pointIndex, true);
            return;
        }
        // keep options in snyc if chart is not initialized
        if (this.options.series.length > serieIndex &&
            this.options.series[serieIndex].data.length > pointIndex) {
            this.options.series[serieIndex].data.splice(pointIndex, 1);
        }
    }
    /**
     * Remove Series
     * \@memberof Chart
     * @param {?} serieIndex    Index position of series to remove.
     * @return {?}
     */
    removeSerie(serieIndex) {
        if (this.ref && this.ref.series.length > serieIndex) {
            this.ref.series[serieIndex].remove(true);
            return;
        }
        // keep options in snyc if chart is not initialized
        if (this.options.series.length > serieIndex) {
            this.options.series.splice(serieIndex, 1);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Felix Itzenplitz. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at
 * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
 */
class MapChart {
    /**
     * @param {?} options
     */
    constructor(options) {
        this.options = options;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright Felix Itzenplitz. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at
 * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
 *
 * @author Felix Itzenplitz
 * @author Timothy A. Perez (contributor)
 */
class StockChart {
    /**
     * @param {?=} options
     */
    constructor(options = { series: [] }) {
        this.options = options;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ChartDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!changes["chart"].isFirstChange()) {
            this.destroy();
            this.init();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.init();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy(true);
    }
    /**
     * @return {?}
     */
    init() {
        if (this.chart instanceof Chart) {
            return this.chart.ref = chart(this.el.nativeElement, this.chart.options);
        }
        if (this.chart instanceof StockChart) {
            return this.chart.ref = stockChart(this.el.nativeElement, this.chart.options);
        }
        if (this.chart instanceof MapChart) {
            return this.chart.ref = mapChart(this.el.nativeElement, this.chart.options);
        }
    }
    /**
     * @param {?=} sync
     * @return {?}
     */
    destroy(sync = false) {
        if (this.chart && this.chart.ref) {
            if (sync) {
                this.chart.options = this.chart.ref.options;
            }
            this.chart.ref.destroy();
            delete this.chart.ref;
        }
    }
}
ChartDirective.ɵfac = function ChartDirective_Factory(t) { return new (t || ChartDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ChartDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ChartDirective, selectors: [["", "chart", ""]], inputs: { chart: "chart" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
ChartDirective.ctorParameters = () => [
    { type: ElementRef, },
];
ChartDirective.propDecorators = {
    "chart": [{ type: Input },],
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartDirective, [{
        type: Directive,
        args: [{
                selector: '[chart]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { chart: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
let /** @type {?} */ HIGHCHARTS_MODULES = new InjectionToken('HighchartsModules');
class ChartService {
    /**
     * @param {?} chartModules
     */
    constructor(chartModules) {
        this.chartModules = chartModules;
    }
    /**
     * @return {?}
     */
    initModules() {
        this.chartModules.forEach(chartModule => {
            chartModule(Highcharts);
        });
    }
}
ChartService.ɵfac = function ChartService_Factory(t) { return new (t || ChartService)(ɵngcc0.ɵɵinject(HIGHCHARTS_MODULES)); };
ChartService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ChartService, factory: ChartService.ɵfac });
/** @nocollapse */
ChartService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [HIGHCHARTS_MODULES,] },] },
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartService, [{
        type: Injectable
    }], function () { return [{ type: Array, decorators: [{
                type: Inject,
                args: [HIGHCHARTS_MODULES]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const ɵ0 = [];
class ChartModule {
    /**
     * @param {?} cs
     */
    constructor(cs) {
        this.cs = cs;
        this.cs.initModules();
    }
}
ChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ChartModule });
ChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ChartModule_Factory(t) { return new (t || ChartModule)(ɵngcc0.ɵɵinject(ChartService)); }, providers: [
        { provide: HIGHCHARTS_MODULES, useValue: ɵ0 },
        ChartService
    ] });
/** @nocollapse */
ChartModule.ctorParameters = () => [
    { type: ChartService, },
];
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChartModule, { declarations: [ChartDirective], exports: [ChartDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartModule, [{
        type: NgModule,
        args: [{
                exports: [ChartDirective],
                declarations: [ChartDirective],
                providers: [
                    { provide: HIGHCHARTS_MODULES, useValue: ɵ0 },
                    ChartService
                ]
            }]
    }], function () { return [{ type: ChartService }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { ChartModule, HIGHCHARTS_MODULES, Chart, StockChart, MapChart, ChartDirective as ɵb, ChartService as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1oaWdoY2hhcnRzLmpzIiwic291cmNlcyI6WyJhbmd1bGFyLWhpZ2hjaGFydHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4S0FLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvR0FHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O1NBVUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O3NFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGlnaGNoYXJ0cyBmcm9tICdoaWdoY2hhcnRzJztcbmltcG9ydCB7IGNoYXJ0LCBzdG9ja0NoYXJ0LCBtYXBDaGFydCB9IGZyb20gJ2hpZ2hjaGFydHMnO1xuZXhwb3J0IHsgSGlnaGNoYXJ0cyB9O1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5jbGFzcyBDaGFydCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc2V0IG9wdGlvbnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVmLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWYub3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7IHNlcmllczogW10gfSkge1xuICAgICAgICAvLyBpbml0IHNlcmllcyBhcnJheSBpZiBub3Qgc2V0XG4gICAgICAgIGlmICghb3B0aW9ucy5zZXJpZXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2VyaWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIFBvaW50XG4gICAgICogXFxAbWVtYmVyb2YgQ2hhcnRcbiAgICAgKiBAcGFyYW0gez99IHBvaW50ICAgICAgICAgSGlnaGNoYXJ0cy5EYXRhUG9pbnQsIG51bWJlciB0b3VwbGUgb3IgbnVtYmVyXG4gICAgICogQHBhcmFtIHs/PX0gc2VyaWVJbmRleCAgICBJbmRleCBwb3NpdGlvbiBvZiBzZXJpZXMuIFRoaXMgZGVmYXVsdHMgdG8gMC5cbiAgICAgKiBAcGFyYW0gez89fSByZWRyYXcgICAgICAgIEZsYWcgd2hldGhlciBvciBub3QgdG8gcmVkcmF3IHBvaW50LiBUaGlzIGRlZmF1bHRzIHRvIHRydWUuXG4gICAgICogQHBhcmFtIHs/PX0gc2hpZnQgICAgICAgICBTaGlmdCBwb2ludCB0byB0aGUgc3RhcnQgb2Ygc2VyaWVzLiBUaGlzIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgYWRkUG9pbnQocG9pbnQsIHNlcmllSW5kZXggPSAwLCByZWRyYXcgPSB0cnVlLCBzaGlmdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZiAmJiB0aGlzLnJlZi5zZXJpZXMubGVuZ3RoID4gc2VyaWVJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5yZWYuc2VyaWVzW3NlcmllSW5kZXhdLmFkZFBvaW50KHBvaW50LCByZWRyYXcsIHNoaWZ0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWVwIG9wdGlvbnMgaW4gc255YyBpZiBjaGFydCBpcyBub3QgaW5pdGlhbGl6ZWRcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZXJpZXMubGVuZ3RoID4gc2VyaWVJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlcmllc1tzZXJpZUluZGV4XS5kYXRhLnB1c2gocG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBTZXJpZXNcbiAgICAgKiBcXEBtZW1iZXJvZiBDaGFydFxuICAgICAqIEBwYXJhbSB7P30gc2VyaWUgICAgICAgICBTZXJpZXMgQ29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IHJlZHJhdyAgICAgICAgRmxhZyB3aGV0aGVyIG9yIG5vdCB0byByZWRyYXcgc2VyaWVzLiBUaGlzIGRlZmF1bHRzIHRvIHRydWUuXG4gICAgICogQHBhcmFtIHs/PX0gYW5pbWF0aW9uICAgICBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uIGNvbmZpZ3VyYXRpb24uIFRoaXMgZGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBhZGRTZXJpZShzZXJpZSwgcmVkcmF3ID0gdHJ1ZSwgYW5pbWF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlZi5hZGRTZXJpZXMoc2VyaWUsIHJlZHJhdywgYW5pbWF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWVwIG9wdGlvbnMgaW4gc255YyBpZiBjaGFydCBpcyBub3QgaW5pdGlhbGl6ZWRcbiAgICAgICAgdGhpcy5vcHRpb25zLnNlcmllcy5wdXNoKHNlcmllKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIFBvaW50XG4gICAgICogXFxAbWVtYmVyb2YgQ2hhcnRcbiAgICAgKiBAcGFyYW0gez99IHBvaW50SW5kZXggICAgSW5kZXggb2YgUG9pbnRcbiAgICAgKiBAcGFyYW0gez89fSBzZXJpZUluZGV4ICAgIFNwZWNpZmllZCBJbmRleCBvZiBTZXJpZXMuIERlZmF1bHRzIHRvIDAuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICByZW1vdmVQb2ludChwb2ludEluZGV4LCBzZXJpZUluZGV4ID0gMCkge1xuICAgICAgICBpZiAodGhpcy5yZWYgJiZcbiAgICAgICAgICAgIHRoaXMucmVmLnNlcmllcy5sZW5ndGggPiBzZXJpZUluZGV4ICYmXG4gICAgICAgICAgICB0aGlzLnJlZi5zZXJpZXNbc2VyaWVJbmRleF0uZGF0YS5sZW5ndGggPiBwb2ludEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnJlZi5zZXJpZXNbc2VyaWVJbmRleF0ucmVtb3ZlUG9pbnQocG9pbnRJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8ga2VlcCBvcHRpb25zIGluIHNueWMgaWYgY2hhcnQgaXMgbm90IGluaXRpYWxpemVkXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VyaWVzLmxlbmd0aCA+IHNlcmllSW5kZXggJiZcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZXJpZXNbc2VyaWVJbmRleF0uZGF0YS5sZW5ndGggPiBwb2ludEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VyaWVzW3NlcmllSW5kZXhdLmRhdGEuc3BsaWNlKHBvaW50SW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBTZXJpZXNcbiAgICAgKiBcXEBtZW1iZXJvZiBDaGFydFxuICAgICAqIEBwYXJhbSB7P30gc2VyaWVJbmRleCAgICBJbmRleCBwb3NpdGlvbiBvZiBzZXJpZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgcmVtb3ZlU2VyaWUoc2VyaWVJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5yZWYgJiYgdGhpcy5yZWYuc2VyaWVzLmxlbmd0aCA+IHNlcmllSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMucmVmLnNlcmllc1tzZXJpZUluZGV4XS5yZW1vdmUodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8ga2VlcCBvcHRpb25zIGluIHNueWMgaWYgY2hhcnQgaXMgbm90IGluaXRpYWxpemVkXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VyaWVzLmxlbmd0aCA+IHNlcmllSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZXJpZXMuc3BsaWNlKHNlcmllSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgRmVsaXggSXR6ZW5wbGl0ei4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL2NlYm9yL2FuZ3VsYXItaGlnaGNoYXJ0cy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cbmNsYXNzIE1hcENoYXJ0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgRmVsaXggSXR6ZW5wbGl0ei4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL2NlYm9yL2FuZ3VsYXItaGlnaGNoYXJ0cy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogQGF1dGhvciBGZWxpeCBJdHplbnBsaXR6XG4gKiBAYXV0aG9yIFRpbW90aHkgQS4gUGVyZXogKGNvbnRyaWJ1dG9yKVxuICovXG5jbGFzcyBTdG9ja0NoYXJ0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHsgc2VyaWVzOiBbXSB9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5jbGFzcyBDaGFydERpcmVjdGl2ZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghY2hhbmdlc1tcImNoYXJ0XCJdLmlzRmlyc3RDaGFuZ2UoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYXJ0IGluc3RhbmNlb2YgQ2hhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LnJlZiA9IGNoYXJ0KHRoaXMuZWwubmF0aXZlRWxlbWVudCwgdGhpcy5jaGFydC5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGFydCBpbnN0YW5jZW9mIFN0b2NrQ2hhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LnJlZiA9IHN0b2NrQ2hhcnQodGhpcy5lbC5uYXRpdmVFbGVtZW50LCB0aGlzLmNoYXJ0Lm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYXJ0IGluc3RhbmNlb2YgTWFwQ2hhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LnJlZiA9IG1hcENoYXJ0KHRoaXMuZWwubmF0aXZlRWxlbWVudCwgdGhpcy5jaGFydC5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzeW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBkZXN0cm95KHN5bmMgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5jaGFydCAmJiB0aGlzLmNoYXJ0LnJlZikge1xuICAgICAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0Lm9wdGlvbnMgPSB0aGlzLmNoYXJ0LnJlZi5vcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFydC5yZWYuZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hhcnQucmVmO1xuICAgICAgICB9XG4gICAgfVxufVxuQ2hhcnREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjaGFydF0nXG4gICAgICAgICAgICB9LF0gfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cbkNoYXJ0RGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiwgfSxcbl07XG5DaGFydERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBcImNoYXJ0XCI6IFt7IHR5cGU6IElucHV0IH0sXSxcbn07XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbmxldCAvKiogQHR5cGUgez99ICovIEhJR0hDSEFSVFNfTU9EVUxFUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignSGlnaGNoYXJ0c01vZHVsZXMnKTtcbmNsYXNzIENoYXJ0U2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFydE1vZHVsZXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFydE1vZHVsZXMpIHtcbiAgICAgICAgdGhpcy5jaGFydE1vZHVsZXMgPSBjaGFydE1vZHVsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgaW5pdE1vZHVsZXMoKSB7XG4gICAgICAgIHRoaXMuY2hhcnRNb2R1bGVzLmZvckVhY2goY2hhcnRNb2R1bGUgPT4ge1xuICAgICAgICAgICAgY2hhcnRNb2R1bGUoSGlnaGNoYXJ0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkNoYXJ0U2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuQ2hhcnRTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW0hJR0hDSEFSVFNfTU9EVUxFUyxdIH0sXSB9LFxuXTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuY29uc3QgybUwID0gW107XG5jbGFzcyBDaGFydE1vZHVsZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNzKSB7XG4gICAgICAgIHRoaXMuY3MgPSBjcztcbiAgICAgICAgdGhpcy5jcy5pbml0TW9kdWxlcygpO1xuICAgIH1cbn1cbkNoYXJ0TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbQ2hhcnREaXJlY3RpdmVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0NoYXJ0RGlyZWN0aXZlXSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBISUdIQ0hBUlRTX01PRFVMRVMsIHVzZVZhbHVlOiDJtTAgfSxcbiAgICAgICAgICAgICAgICAgICAgQ2hhcnRTZXJ2aWNlXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5DaGFydE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENoYXJ0U2VydmljZSwgfSxcbl07XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG5leHBvcnQgeyBDaGFydE1vZHVsZSwgSElHSENIQVJUU19NT0RVTEVTLCBDaGFydCwgU3RvY2tDaGFydCwgTWFwQ2hhcnQsIENoYXJ0RGlyZWN0aXZlIGFzIMm1YiwgQ2hhcnRTZXJ2aWNlIGFzIMm1YSB9O1xuIl19